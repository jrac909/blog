(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{429:function(t,a,s){"use strict";s.r(a);var o=s(62),r=Object(o.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"pod-概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pod-概念"}},[t._v("#")]),t._v(" pod 概念")]),t._v(" "),s("h3",{attrs:{id:"pod-分类-非官方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pod-分类-非官方"}},[t._v("#")]),t._v(" pod 分类（非官方）")]),t._v(" "),s("p",[t._v("🐸 1. 自主式 pod（不是被控制器管理的 pod）：一旦死亡不会被拉起来，不会重启"),s("br"),t._v("\n🐸 2. 控制器管理的 pod")]),t._v(" "),s("h3",{attrs:{id:"为什么要使用-pod"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用-pod"}},[t._v("#")]),t._v(" 为什么要使用 pod？")]),t._v(" "),s("p",[t._v("在传统情况下，比如使用 docker。一个完整项目需要两个服务，比如服务 A、服务 B，他们都有单独的 image，在主机上运行这两个 image，得到两个完全隔离的容器，每一个容器都有自己的 ip 地址、挂载卷。此时，进行 k8s 移植就很不容易，要彼此访问就很麻烦也不安全，除非我们重新 build 一个镜像包含了这两个镜像，或者让其中一个容器访问另一个容器的网络栈。所以，提出了 pod 的解决方案。")]),t._v(" "),s("h3",{attrs:{id:"pod-方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pod-方案"}},[t._v("#")]),t._v(" pod 方案")]),t._v(" "),s("p",[t._v("只要定义了一个 pod，就会在这个 pod 中启动一个 pause 容器。当我们在这个 pod 中定义其他容器时，这些容器可以共用 pause 容器的网络栈、存储卷。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("共用网络栈：意味着这些容器没有独立的 ip 地址，有的都是 pause 或者这个 pod 的地址，这些容器之间进程不隔离，访问只需要 localhost 即可访问；同时也意味着同一个 pod 中，端口不能重复")])]),t._v(" "),s("h3",{attrs:{id:"控制器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制器"}},[t._v("#")]),t._v(" 控制器")]),t._v(" "),s("h2",{attrs:{id:"网络通讯方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络通讯方式"}},[t._v("#")]),t._v(" 网络通讯方式")])])}),[],!1,null,null,null);a.default=r.exports}}]);