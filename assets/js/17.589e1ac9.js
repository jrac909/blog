(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{432:function(v,_,o){"use strict";o.r(_);var t=o(62),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h1",{attrs:{id:"现代前端组合概念-monorepo"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#现代前端组合概念-monorepo"}},[v._v("#")]),v._v(" 现代前端组合概念 - Monorepo")]),v._v(" "),o("p",[v._v("🍁 "),o("code",[v._v("monorepo")]),v._v(" 是一种将两个或多个项目的代码存储在同一仓库的软件开发策略。")]),v._v(" "),o("h2",{attrs:{id:"背景"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[v._v("#")]),v._v(" 背景")]),v._v(" "),o("p",[v._v("  比如现在有一个庞大的前端项目 Biggg, Biggg 提供云存储、游戏、工具软件等各类服务，但是这些服务之间又可以互相调用，并且这个服务还有公共使用的模块，我们如何进行这个项目的开发？")]),v._v(" "),o("p",[o("strong",[v._v("1. 单体结构")])]),v._v(" "),o("p",[v._v("  也就是说整个项目存储在一个版本仓库中，不进行任何分离，所有的设计、重构、测试、部署都在一个巨大的单元中处理。这样处理优缺点如下：")]),v._v(" "),o("ul",[o("li",[v._v("✔️ 部署简单")]),v._v(" "),o("li",[v._v("✔️ 技术单一")]),v._v(" "),o("li",[v._v("✔️ 用人成本低")]),v._v(" "),o("li",[v._v("❌ 项目体积过大，系统启动慢")]),v._v(" "),o("li",[v._v("❌ 系统隔离性差，一个问题可能会导致整个系统宕机")]),v._v(" "),o("li",[v._v("❌ 逻辑复杂，开发效率低")])]),v._v(" "),o("p",[o("strong",[v._v("2. 多仓库结构 multirepo")])]),v._v(" "),o("p",[v._v("  将项目的多个服务拆分成单独的项目，并且存储在独立的仓库中，每个项目具有独立的开发、测试、构建、部署方案。这样处理优缺点如下：")]),v._v(" "),o("ul",[o("li",[v._v("✔️ 项目高度独立")]),v._v(" "),o("li",[v._v("❌ 创建新模块过于繁琐，要考虑到独立的测试、部署等问题")]),v._v(" "),o("li",[v._v("❌ 较多的重复代码，公共的工具类模块一般写在独立的子项目中")]),v._v(" "),o("li",[v._v("❌ 跨仓库依赖的相关问题")])]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),o("p",[v._v("不要混淆微前端和 multirepo")])]),v._v(" "),o("p",[o("strong",[v._v("3. monorepo 策略")])]),v._v(" "),o("p",[v._v("  为了解决上述两种结构的缺陷，我们需要这样一种策略：能够适当的分离模块，同时又方便引用分离的模块，同时能高效地进行测试、构建和部署。基于这些需求，出现了 monorepo 策略。")]),v._v(" "),o("h2",{attrs:{id:"什么是-monorepo-策略"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是-monorepo-策略"}},[v._v("#")]),v._v(" 什么是 monorepo 策略？")]),v._v(" "),o("p",[v._v("  monorepo 是一种将多个项目代码存储在一个仓库里的软件开发策略。每一个模块仍作为独立的项目，但是存储在同一个仓库中。具体解决了如下问题：")]),v._v(" "),o("ul",[o("li",[v._v("创建新的子项目时，不需要考虑开发环境、CI/CD、构建发布。")]),v._v(" "),o("li",[v._v("依赖包位于同一仓库，因此无需将版本化包发布到 npm 注册表之类的地方。")]),v._v(" "),o("li",[v._v("每次提交的时候，一切都会协同工作。受变更影响的组织可以很容易地看到变更。")])]),v._v(" "),o("h2",{attrs:{id:"什么情况下适用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下适用"}},[v._v("#")]),v._v(" 什么情况下适用？")]),v._v(" "),o("ul",[o("li",[v._v("一组类似产品")]),v._v(" "),o("li",[v._v("需要直观了解多个项目的变化")]),v._v(" "),o("li",[v._v("一组重用通用功能的相关项目")])]),v._v(" "),o("h2",{attrs:{id:"有哪些帮助构建-monorepo-的工具"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#有哪些帮助构建-monorepo-的工具"}},[v._v("#")]),v._v(" 有哪些帮助构建 monorepo 的工具？")]),v._v(" "),o("ul",[o("li",[v._v("Lerna")]),v._v(" "),o("li",[v._v("Yarn Workspaces")]),v._v(" "),o("li",[v._v("npm Workspaces")]),v._v(" "),o("li",[v._v("pnmp")]),v._v(" "),o("li",[v._v("Nx")]),v._v(" "),o("li",[v._v("Turborepo")]),v._v(" "),o("li",[v._v("Yalc")]),v._v(" "),o("li",[v._v("Rush")])])])}),[],!1,null,null,null);_.default=r.exports}}]);