# 现代前端组合概念 - Monorepo
:maple_leaf: `monorepo` 是一种将两个或多个项目的代码存储在同一仓库的软件开发策略。

## 背景
&emsp;&emsp;比如现在有一个庞大的前端项目 Biggg, Biggg 提供云存储、游戏、工具软件等各类服务，但是这些服务之间又可以互相调用，并且这个服务还有公共使用的模块，我们如何进行这个项目的开发？

**1. 单体结构**

&emsp;&emsp;也就是说整个项目存储在一个版本仓库中，不进行任何分离，所有的设计、重构、测试、部署都在一个巨大的单元中处理。这样处理优缺点如下：
- :heavy_check_mark: 部署简单
- :heavy_check_mark: 技术单一
- :heavy_check_mark: 用人成本低
- :x: 项目体积过大，系统启动慢
- :x: 系统隔离性差，一个问题可能会导致整个系统宕机
- :x: 逻辑复杂，开发效率低

**2. 多仓库结构 multirepo**

&emsp;&emsp;将项目的多个服务拆分成单独的项目，并且存储在独立的仓库中，每个项目具有独立的开发、测试、构建、部署方案。这样处理优缺点如下：
- :heavy_check_mark: 项目高度独立
- :x: 创建新模块过于繁琐，要考虑到独立的测试、部署等问题
- :x: 较多的重复代码，公共的工具类模块一般写在独立的子项目中
- :x: 跨仓库依赖的相关问题

::: tip 注意
不要混淆微前端和 multirepo
:::

**3. monorepo 策略**

&emsp;&emsp;为了解决上述两种结构的缺陷，我们需要这样一种策略：能够适当的分离模块，同时又方便引用分离的模块，同时能高效地进行测试、构建和部署。基于这些需求，出现了 monorepo 策略。

## 什么是 monorepo 策略？
&emsp;&emsp;monorepo 是一种将多个项目代码存储在一个仓库里的软件开发策略。每一个模块仍作为独立的项目，但是存储在同一个仓库中。具体解决了如下问题：
- 创建新的子项目时，不需要考虑开发环境、CI/CD、构建发布。
- 依赖包位于同一仓库，因此无需将版本化包发布到 npm 注册表之类的地方。
- 每次提交的时候，一切都会协同工作。受变更影响的组织可以很容易地看到变更。

## 什么情况下适用？
- 一组类似产品
- 需要直观了解多个项目的变化
- 一组重用通用功能的相关项目

## 有哪些帮助构建 monorepo 的工具？
- Lerna
- Yarn Workspaces
- npm Workspaces
- pnmp
- Nx
- Turborepo
- Yalc
- Rush