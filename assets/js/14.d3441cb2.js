(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{428:function(t,s,e){"use strict";e.r(s);var a=e(62),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"cmd-和-entrypoint-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cmd-和-entrypoint-的区别"}},[t._v("#")]),t._v(" CMD 和 ENTRYPOINT 的区别")]),t._v(" "),e("p",[t._v("这两个指令都可以执行命令，区别如下：")]),t._v(" "),e("ul",[e("li",[t._v("🐥 CMD: 指定这个容器启动的时候运行的命令，只有最后一个会生效，可被替代")]),t._v(" "),e("li",[t._v("🐥 ENTRYPOINT: 指定这个容器启动的时候要运行的命令, 可以追加命令")])]),t._v(" "),e("h3",{attrs:{id:"举例测试-cmd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#举例测试-cmd"}},[t._v("#")]),t._v(" 举例测试 CMD")]),t._v(" "),e("p",[t._v("🐸 "),e("strong",[t._v("1")]),t._v(" . 创建 DockerFile 文件，比如：dockerfile-cmd-test，内容如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('# 一个简单的镜像：启动的时候执行命令 ls -a\nFROM centos\nCMD ["ls", "-a"]\n')])])]),e("p",[t._v("🐸 "),e("strong",[t._v("2")]),t._v(". 构建镜像")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# -f 指定镜像文件；-t 指定构建的镜像名（也可以加 tag）\ndocker build -f docker-file-test -t cmdtest\n")])])]),e("p",[t._v("🐸 "),e("strong",[t._v("3")]),t._v(". 启动容器")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 可以看到在启动后，容器直接执行了 ls -a 命令，打印了当前文件夹下的文件信息\ndocker run cmdtest\n")])])]),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v('一般来说，我们在执行 run 命令的时候可以同时执行一些命令，比如 docker run -it sh "while(true) do echo loop; done;"')])]),t._v(" "),e("p",[t._v("🐸 "),e("strong",[t._v("4")]),t._v(". 在启动容器的时候追加命令，比如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# cmdtest 镜像中有 ls -a 命令，我们想在后面追加 -l 参数，所以在 run 的时候加一个 -l\ndocker run cmdtest -l\n")])])]),e("p",[t._v('此时会报错。因为 cmd 的清理下 -l 替换了 CMD ["ls", "-a"] 命令, -l 不是命令所以报错。所以，我们可以发现，run 中的命令会替换掉 DockerFile 文件中 CMD 的命令。因此我们想要在 docker run 正常替换，可以如下执行：')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 写一个完整的路径\ndocker run cmdtest ls -al\n")])])]),e("hr"),t._v(" "),e("h3",{attrs:{id:"举例测试-entrypoint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#举例测试-entrypoint"}},[t._v("#")]),t._v(" 举例测试 ENTRYPOINT")]),t._v(" "),e("p",[t._v("🐸 "),e("strong",[t._v("1")]),t._v(". 创建 DockerFile 文件 dockerfile-entrypoint-test")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('# 同 CMD，只是指令替换为 ENTRYPOINT\nFROM  centos\nENTRYPOINT ["ls", "-a"]\n')])])]),e("p",[t._v("🐸 "),e("strong",[t._v("2")]),t._v(". 构建镜像")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker build -f dockerfile-entrypoint-test -t entrypointtest\n")])])]),e("p",[t._v("🐸 "),e("strong",[t._v("3")]),t._v(". 启动容器")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 可以看到和 CMD 指令运行结果一样，看不出任何区别\ndocker run entrypointtest\n")])])]),e("p",[t._v("🐸 "),e("strong",[t._v("4")]),t._v(". 在启动容器的时候追加命令")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("docker run entrypointtest -l\n")])])]),e("p",[t._v("可以看到最终的执行结果是：ls -al，也就是说 -l 参数被追加到了 ls -a 命令后面。")])])}),[],!1,null,null,null);s.default=r.exports}}]);