(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{439:function(t,e,a){"use strict";a.r(e);var l=a(62),o=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"问题-更新的粒度是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-更新的粒度是什么"}},[t._v("#")]),t._v(" 问题：更新的粒度是什么？")]),t._v(" "),a("ul",[a("li",[t._v("比较的最小粒度是标签，是节点。但是变化的标签里面嵌套了新的标签，并且被嵌套的标签没有变化，那么被嵌套的标签会被复用。")])]),t._v(" "),a("h2",{attrs:{id:"问题-遍历中的-key-有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-遍历中的-key-有什么作用"}},[t._v("#")]),t._v(" 问题：遍历中的 key 有什么作用？")]),t._v(" "),a("ul",[a("li",[t._v("当状态中的数据发生变化时，react 会根据新数据生成新的虚拟 dom，随后 react 进行新虚拟 dom与旧虚拟 dom 的 diff 比较，比较规则如下：\n"),a("ul",[a("li",[a("p",[t._v("旧虚拟 dom 中找到了与新虚拟 dom 相同的 key：")]),t._v(" "),a("ul",[a("li",[t._v("若虚拟 dom 中内容没变，直接使用之前的真实 dom")]),t._v(" "),a("li",[t._v("若虚拟 dom 中内容变了，则生成新的真实 dom，随后替换掉页面之前的真实 dom")])])]),t._v(" "),a("li",[a("p",[t._v("旧虚拟 dom 中未找到与新虚拟 dom 相同的 key：")]),t._v(" "),a("ul",[a("li",[t._v("根据数据创建新的真实 dom，随后渲染到页面")])])])])])]),t._v(" "),a("h2",{attrs:{id:"问题-用-index-作为-key-可能会遇到的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题-用-index-作为-key-可能会遇到的问题"}},[t._v("#")]),t._v(" 问题：用 index 作为 key 可能会遇到的问题？")]),t._v(" "),a("ol",[a("li",[t._v("若对数据进行：逆序添加、逆序删除等破坏顺序操作；会产生没有必要的 dom 更新 => 界面效果没问题，但效率低")]),t._v(" "),a("li",[t._v("如果结构中还包含输入类的操作：会产生错误 dom 更新 => 界面有问题")]),t._v(" "),a("li",[t._v("注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。")])])])}),[],!1,null,null,null);e.default=o.exports}}]);